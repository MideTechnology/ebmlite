from collections import OrderedDict
from datetime import datetime
from typing import Any, BinaryIO, Optional, Union

class Element:
    schema: Any = ...
    dtype: Any = ...
    precache: bool = ...
    mandatory: bool = ...
    multiple: bool = ...
    length: Any = ...
    children: Any = ...
    def parse(self, stream: BinaryIO, size: int) -> Any: ...
    stream: Any = ...
    offset: Any = ...
    size: Any = ...
    payloadOffset: Any = ...
    def __init__(self, stream: Any=..., offset: int=..., size: int=..., payloadOffset: int=...) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    @property
    def value(self) -> Any: ...
    def getRaw(self) -> Union[bytes, bytearray]: ...
    def getRawValue(self) -> Union[bytes, bytearray]: ...
    def gc(self, recurse: bool=...) -> int: ...
    @classmethod
    def encodePayload(cls: Any, data: Any, length: Optional[int]=...) -> bytes: ...
    @classmethod
    def encode(cls: Any, value: Any, length: Optional[int]=..., lengthSize: Optional[int]=..., infinite: bool=...) -> bytes: ...
    def dump(self): ...

class IntegerElement(Element):
    dtype: Any = ...
    precache: bool = ...
    def __eq__(self, other: Any) -> Any: ...
    def parse(self, stream: BinaryIO, size: int) -> int: ...
    @classmethod
    def encodePayload(cls: Any, data: int, length: Optional[int]=...) -> bytes: ...

class UIntegerElement(IntegerElement):
    dtype: Any = ...
    precache: bool = ...
    def parse(self, stream: BinaryIO, size: int) -> int: ...
    @classmethod
    def encodePayload(cls: Any, data: int, length: Optional[int]=...) -> bytes: ...

class FloatElement(Element):
    dtype: Any = ...
    precache: bool = ...
    def __eq__(self, other: Any) -> Any: ...
    def parse(self, stream: BinaryIO, size: int) -> float: ...
    @classmethod
    def encodePayload(cls: Any, data: float, length: Optional[int]=...) -> bytes: ...

class StringElement(Element):
    dtype: Any = ...
    def __eq__(self, other: Any) -> Any: ...
    def __len__(self): ...
    def parse(self, stream: BinaryIO, size: int) -> bytes: ...
    @classmethod
    def encodePayload(cls: Any, data: Union[bytes, bytearray], length: Optional[int]=...) -> bytes: ...

class UnicodeElement(StringElement):
    dtype: Any = ...
    def __len__(self): ...
    def parse(self, stream: BinaryIO, size: int) -> str: ...
    @classmethod
    def encodePayload(cls: Any, data: str, length: Optional[int]=...) -> bytes: ...

class DateElement(IntegerElement):
    dtype: datetime = ...
    def parse(self, stream: BinaryIO, size: int) -> datetime: ...
    @classmethod
    def encodePayload(cls: Any, data: datetime, length: Optional[int]=...) -> bytes: ...

class BinaryElement(Element):
    def __len__(self): ...

class VoidElement(BinaryElement):
    def parse(self, stream: BinaryIO, size: Any) -> Any: ...
    @classmethod
    def encodePayload(cls: Any, data: Any, length: Optional[int]=...) -> bytearray: ...

class UnknownElement(BinaryElement):
    name: str = ...
    precache: bool = ...
    id: Any = ...
    schema: Any = ...
    def __init__(self, stream: Optional[BinaryIO]=..., offset: int=..., size: int=..., payloadOffset: int=..., eid: Optional[int]=..., schema: Any=...) -> None: ...
    def __eq__(self, other: Any) -> Any: ...

class MasterElement(Element):
    dtype: Any = ...
    def parse(self): ...
    def parseElement(self, stream: BinaryIO, nocache: bool=...) -> Any: ...
    @property
    def size(self) -> int: ...
    @size.setter
    def size(self, esize: int) -> Any: ...
    def __iter__(self, nocache: bool=...) -> Any: ...
    def __len__(self): ...
    @property
    def value(self): ...
    def __getitem__(self, *args: Any): ...
    def gc(self, recurse: bool=...) -> int: ...
    @classmethod
    def encodePayload(cls: Any, data: Any, length: Optional[int]=...) -> bytearray: ...
    @classmethod
    def encode(cls: Any, data: Any, length: Optional[int]=..., lengthSize: Optional[int]=..., infinite: bool=...) -> bytes: ...
    def dump(self) -> OrderedDict: ...

class Document(MasterElement):
    stream: Any = ...
    size: Any = ...
    name: Any = ...
    id: Any = ...
    offset: Any = ...
    filename: Any = ...
    info: Any = ...
    payloadOffset: Any = ...
    def __init__(self, stream: Any, name: Optional[str]=..., size: Optional[int]=..., headers: bool=...) -> None: ...
    def close(self) -> None: ...
    def __len__(self): ...
    def __iter__(self, nocache: bool = ...) -> Any: ...
    @property
    def value(self): ...
    def __getitem__(self, idx: Any): ...
    @property
    def version(self): ...
    @property
    def type(self): ...
    def gc(self, recurse: bool=...) -> int: ...
    @classmethod
    def encode(cls, stream: Any, data: Any, headers: bool = ..., **kwargs: Any) -> None: ...

class Schema:
    BASE_CLASSES: Any = ...
    ELEMENT_TYPES: Any = ...
    UNKNOWN: Any = ...
    source: Any = ...
    filename: Any = ...
    elements: Any = ...
    elementsByName: Any = ...
    elementInfo: Any = ...
    globals: Any = ...
    children: Any = ...
    name: Any = ...
    document: Any = ...
    def __init__(self, source: Any, name: Optional[Union[str, bytes, bytearray]]=...) -> None: ...
    def addElement(self, eid: int, ename: Union[str, bytes, bytearray], baseClass: Any, attribs: Any=..., parent: Any=..., docs: Any=...) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __contains__(self, key: Any): ...
    def __getitem__(self, key: Any): ...
    def get(self, key: Any, default: Optional[Any] = ...): ...
    def load(self, fp: Any, name: Optional[Any] = ..., headers: bool = ..., **kwargs: Any): ...
    def loads(self, data: Any, name: Optional[Any] = ...): ...
    def __call__(self, fp: Any, name: Optional[Any] = ...): ...
    @property
    def version(self): ...
    @property
    def type(self): ...
    def encode(self, stream: BinaryIO, data: Any, headers: Any=...) -> bytes: ...
    def encodes(self, data: Any, headers: bool = ...): ...
    def verify(self, data: Any): ...

def loadSchema(filename: Union[str, bytes, bytearray], reload: Any=..., **kwargs: Any) -> Any: ...
